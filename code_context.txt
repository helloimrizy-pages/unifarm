// File: animal_manager.py
import pygame
import random
from animal import Animal
from constants import *

class AnimalManager:
    def __init__(self, game_state, terrain):
        self.game_state = game_state
        self.terrain = terrain
        self.animals = []
        self.animals_group = pygame.sprite.Group()
        self.buildings = None
        
        self.species_config = {
            "elephant": {
                "scale": (1.5, 1.5),
                "speed": 3.0,
                "preferred_terrain": "grass",
                "food_consumption": 2.0,
                "water_consumption": 3.0,
                "tourist_appeal": 3.0
            },
            "lion": {
                "scale": (1.0, 1.0),
                "speed": 5.0,
                "preferred_terrain": "grass",
                "food_consumption": 1.5,
                "water_consumption": 1.0,
                "tourist_appeal": 3.5
            },
            "zebra": {
                "scale": (1.2, 0.8),
                "speed": 4.0,
                "preferred_terrain": "grass",
                "food_consumption": 1.0,
                "water_consumption": 1.0,
                "tourist_appeal": 2.0
            }
        }
        
        self.species_colors = {
            "elephant": GRAY,
            "lion": YELLOW,
            "zebra": WHITE
        }
        
        self.initial_population = {
            "elephant": 5,
            "lion": 5,
            "zebra": 10
        }
        
        self.spawn_initial_animals()
    
    def set_building_manager(self, building_manager):
        """Set the building manager (needed to find food/water sources)"""
        self.buildings = building_manager
    
    def spawn_initial_animals(self):
        """Spawn the initial animal population"""
        for species, count in self.initial_population.items():
            for _ in range(count):
                self.spawn_animal(species)
    
    def spawn_animal(self, species, nearby=None, group_id=None):
        spawn_position = self.find_spawn_position(species, nearby)
        animal = Animal(species, spawn_position, self.terrain, self)
        if group_id is not None:
            animal.group_id = group_id
        else:
            animal.group_id = random.randint(1000, 9999)

        self.animals.append(animal)
        self.animals_group.add(animal)
        return animal

    def find_spawn_position(self, species, nearby=None):
        if nearby:
            for _ in range(20):
                dx = random.uniform(-TILE_SIZE * 3, TILE_SIZE * 3)
                dy = random.uniform(-TILE_SIZE * 3, TILE_SIZE * 3)
                pos = (nearby[0] + dx, nearby[1] + dy)
                terrain_type = self.terrain.get_terrain_at_position(pos)
                if species == "crocodile" and terrain_type == "water":
                    return pos
                elif terrain_type == "grass":
                    return pos

        for _ in range(100):
            x = random.uniform(-self.terrain.size * TILE_SIZE / 2, self.terrain.size * TILE_SIZE / 2)
            y = random.uniform(-self.terrain.size * TILE_SIZE / 2, self.terrain.size * TILE_SIZE / 2)
            pos = (x, y)
            terrain_type = self.terrain.get_terrain_at_position(pos)
            if species == "crocodile" and terrain_type == "water":
                return pos
            elif terrain_type == "grass":
                return pos

        return (0, 0)


    def update(self, dt):
        """Update all animals"""
        for animal in list(self.animals):
            animal.step(dt)
            
            if animal.health <= 0:
                self.remove_animal(animal)
        
        self.update_animal_stats()
        
        self.try_natural_spawning(dt)
        self.try_group_reproduction(dt)
        self.update_group_movement(dt)
    
    def remove_animal(self, animal):
        """Remove an animal from the simulation"""
        if animal in self.animals:
            self.animals.remove(animal)
            self.animals_group.remove(animal)
    
    def update_animal_stats(self):
        """Update game state with statistics about animal populations"""
        stats = {}
        
        for species in self.species_config:
            stats[species] = {
                "population": 0,
                "avg_health": 0,
                "avg_hunger": 0,
                "avg_thirst": 0
            }
        
        for animal in self.animals:
            species = animal.species
            stats[species]["population"] += 1
            stats[species]["avg_health"] += animal.health
            stats[species]["avg_hunger"] += animal.hunger
            stats[species]["avg_thirst"] += animal.thirst
        
        for species, data in stats.items():
            pop = data["population"]
            if pop > 0:
                data["avg_health"] /= pop
                data["avg_hunger"] /= pop
                data["avg_thirst"] /= pop
        
        self.game_state.update_ecosystem_balance(stats)
    
    def try_natural_spawning(self, dt):
        """Small chance for animals to naturally spawn"""
        if len(self.animals) >= 40:
            return
        
        species_counts = {}
        for animal in self.animals:
            species = animal.species
            species_counts[species] = species_counts.get(species, 0) + 1
        
        for species, config in self.species_config.items():
            current_count = species_counts.get(species, 0)
            
            max_count = self.initial_population.get(species, 5) * 1.5
            if current_count < max_count:
                if random.random() < 0.005 * dt:
                    self.spawn_animal(species)
                    self.game_state.add_notification(f"A new {species} has appeared!")
    
    def try_group_reproduction(self, dt):
        """Let animal groups reproduce if they meet conditions"""
        group_min_size = 3
        reproduction_cooldown = 30

        if not hasattr(self, "last_reproduction_time"):
            self.last_reproduction_time = {}

        species_groups = {}

        for animal in self.animals:
            if animal.age >= 0.8:
                key = (animal.species, animal.group_id)
                species_groups.setdefault(key, []).append(animal)

        for (species, group_id), group in species_groups.items():
            if len(group) >= group_min_size:
                last_time = self.last_reproduction_time.get((species, group_id), 0)
                if self.game_state.time_elapsed - last_time > reproduction_cooldown:
                    parent = random.choice(group)
                    self.spawn_animal(species, nearby=parent.position, group_id=group_id)
                    self.last_reproduction_time[(species, group_id)] = self.game_state.time_elapsed
                    self.game_state.add_notification(f"{species.capitalize()} group {group_id} reproduced!")

    def get_tourist_appeal(self):
        """Calculate the tourism appeal of the current animal population"""
        if not self.animals:
            return 0
        
        species_present = set([animal.species for animal in self.animals])
        base_appeal = len(species_present) * 30
        
        animal_appeal = 0
        for animal in self.animals:
            species_appeal = self.species_config[animal.species]["tourist_appeal"]
            health_factor = animal.health / 100
            animal_appeal += species_appeal * health_factor
        
        animal_appeal = animal_appeal / len(self.animals)
        
        total_appeal = base_appeal + (animal_appeal * 10)
        
        return min(100, total_appeal)
    
    def render(self, screen, camera_offset):
        """Render all animals with camera offset"""
        for animal in self.animals:
            screen_pos = (animal.position[0] - camera_offset[0], 
                         animal.position[1] - camera_offset[1])
            
            if (screen_pos[0] < -100 or screen_pos[0] > SCREEN_WIDTH + 100 or
                screen_pos[1] < -100 or screen_pos[1] > SCREEN_HEIGHT + 100):
                continue
            
            rect = animal.image.get_rect()
            rect.center = screen_pos
            
            screen.blit(animal.image, rect)
            
            if animal.health < 70:
                bar_width = animal.rect.width
                bar_height = 4
                bar_pos = (screen_pos[0] - bar_width/2, screen_pos[1] - animal.rect.height/2 - 10)
                
                pygame.draw.rect(screen, BLACK, 
                               (bar_pos[0], bar_pos[1], bar_width, bar_height))
                
                health_width = max(0, bar_width * animal.health / 100)
                health_color = GREEN if animal.health > 50 else YELLOW if animal.health > 25 else RED
                pygame.draw.rect(screen, health_color, 
                               (bar_pos[0], bar_pos[1], health_width, bar_height))
    
    def save_animals(self, filename="animals.json"):
        """Save animal data to a file"""
        animal_data = []
        
        for animal in self.animals:
            data = {
                "species": animal.species,
                "position": [animal.position[0], animal.position[1]],
                "hunger": animal.hunger,
                "thirst": animal.thirst,
                "health": animal.health,
                "energy": animal.energy,
                "state": animal.state
            }
            animal_data.append(data)
        
        with open(filename, 'w') as f:
            json.dump(animal_data, f)
        
        return True
    
    def load_animals(self, filename="animals.json"):
        """Load animal data from a file"""
        try:
            with open(filename, 'r') as f:
                animal_data = json.load(f)
            
            for animal in list(self.animals):
                self.remove_animal(animal)
            
            for data in animal_data:
                pos = (data["position"][0], data["position"][1])
                animal = Animal(data["species"], pos, self.terrain, self)
                animal.hunger = data["hunger"]
                animal.thirst = data["thirst"]
                animal.health = data["health"]
                animal.energy = data["energy"]
                animal.state = data["state"]
                self.animals.append(animal)
                self.animals_group.add(animal)
            
            return True
        except Exception as e:
            print(f"Error loading animals: {str(e)}")
            return False
        
    def update_group_movement(self, dt):
        group_centers = {}
        group_members = {}

        for animal in self.animals:
            key = (animal.species, animal.group_id)
            group_members.setdefault(key, []).append(animal)

        for key, members in group_members.items():
            if not members:
                continue
            avg_x = sum(a.position[0] for a in members) / len(members)
            avg_y = sum(a.position[1] for a in members) / len(members)
            group_centers[key] = (avg_x, avg_y)

            for animal in members:
                animal.group_center = group_centers[key]

// File: animal.py
import pygame
import random
import math
from constants import *
from utils import distance

class Animal(pygame.sprite.Sprite):
    def __init__(self, species, position, terrain, animal_manager):
        super().__init__()
        
        config = animal_manager.species_config[species]
        
        width = int(config['scale'][0] * TILE_SIZE)
        height = int(config['scale'][1] * TILE_SIZE)
        
        self.base_image = pygame.Surface((width, height), pygame.SRCALPHA)
        self.base_image.fill(animal_manager.species_colors[species])
        
        pygame.draw.circle(self.base_image, BLACK, 
                          (int(width * 0.7), int(height * 0.5)), 
                          int(width * 0.15))
        
        self.image = self.base_image.copy()
        self.rect = self.image.get_rect()
        self.rect.center = position
        
        self.species = species
        self.position = position
        self.terrain = terrain
        self.manager = animal_manager
        self.game_state = animal_manager.game_state
        self.age = random.uniform(0.2, 1.0)
        self.group_id = random.randint(1000, 9999)
        self.speed = max(30, config['speed'] * self.age * (TILE_SIZE / 32))

        
        self.hunger = random.randint(50, 80)
        self.thirst = random.randint(50, 80)
        self.health = random.randint(70, 100)
        self.energy = random.randint(70, 100)
        
        self.state = "idle"
        self.target = None
        self.target_position = None
        self.wandering = False
        self.wander_timer = 0
        self.need_threshold = 70
        
        self.rotation = 0
        
        self.need_rate = self.game_state.difficulty_settings["animal_need_rate"]
    
    def step(self, dt):
        """Update animal state and perform actions"""
        self.hunger += 0.5 * dt * self.need_rate
        self.thirst += 0.7 * dt * self.need_rate
        self.energy -= 0.3 * dt
        
        self.hunger = min(100, self.hunger)
        self.thirst = min(100, self.thirst)
        self.energy = min(100, self.energy)
        
        if self.hunger > 90 or self.thirst > 90:
            self.health -= 0.5 * dt
        else:
            self.health = min(100, self.health + 0.1 * dt)
        
        self.decide_action()
        
        if self.state == "seeking_food":
            self.seek_food(dt)
        elif self.state == "seeking_water":
            self.seek_water(dt)
        elif self.state == "resting":
            self.rest(dt)
        else:
            self.wander(dt)
        
        self.rect.center = self.position
    
    def decide_action(self):
        """Decide what action to take based on current needs"""
        if self.health < 20:
            if self.hunger > self.thirst:
                self.state = "seeking_food"
            else:
                self.state = "seeking_water"
            return
        
        if self.energy < 20:
            self.state = "resting"
            return
        
        if self.hunger > self.need_threshold:
            self.state = "seeking_food"
        elif self.thirst > self.need_threshold:
            self.state = "seeking_water"
        elif not self.wandering:
            self.state = "idle"
    
    def seek_food(self, dt):
        """Seek out food sources"""
        if not self.is_feeding_station(self.target):
            feeding_stations = [b for b in self.manager.buildings.buildings 
                               if b.building_type == "feeding_station"]
            
            if feeding_stations:
                closest = min(feeding_stations, key=lambda b: distance(self.position, b.position))
                self.target = closest
                self.target_position = closest.position
            else:
                grass_locations = self.find_grass_locations()
                if grass_locations:
                    self.target_position = random.choice(grass_locations)
                else:
                    self.state = "idle"
                    return
        
        if self.target_position:
            self.move_to_target(dt)
            
            if distance(self.position, self.target_position) < TILE_SIZE * 2:
                self.hunger = max(0, self.hunger - 30)
                self.state = "idle"
                self.target = None
                self.target_position = None

    @staticmethod
    def is_water_station(target):
        try:
            return getattr(target, "building_type", None) == "water_station" or \
                (isinstance(target, dict) and target.get("building_type") == "water_station")
        except:
            return False

    @staticmethod
    def is_feeding_station(target):
        try:
            return getattr(target, "building_type", None) == "feeding_station" or \
                (isinstance(target, dict) and target.get("building_type") == "feeding_station")
        except:
            return False
        
    def seek_water(self, dt):
        """Seek out water sources"""
        if not self.is_water_station(self.target):
            water_stations = [b for b in self.manager.buildings.buildings 
                            if b.building_type == "water_station"]

            if water_stations:
                closest = min(water_stations, key=lambda b: distance(self.position, b.position))
                self.target = closest
                self.target_position = closest.position
            else:
                water_locations = self.find_water_locations()
                if water_locations:
                    self.target_position = random.choice(water_locations)
                    self.target = {'position': self.target_position, 'building_type': 'natural_water'}
                else:
                    self.state = "idle"
                    return

        if self.target_position:
            blocked = not self.move_to_target(dt)
            
            if not blocked and distance(self.position, self.target_position) < TILE_SIZE * 2:
                self.thirst = max(0, self.thirst - 40)
                self.state = "idle"
                self.target = None
                self.target_position = None
            elif blocked:
                self.target_position = None
                self.target = None
    
    def rest(self, dt):
        """Rest to regain energy"""
        self.wandering = False
        
        self.energy += 1.0 * dt
        
        if self.energy > 80:
            self.state = "idle"
    
    def wander(self, dt):
        if not self.wandering:
            if hasattr(self, "group_center") and self.group_center:
                gx, gy = self.group_center
                jitter = TILE_SIZE * 3
                x = gx + random.uniform(-jitter, jitter)
                y = gy + random.uniform(-jitter, jitter)
                self.target_position = (x, y)
            else:
                wander_range = 10 * TILE_SIZE
                x = self.position[0] + random.uniform(-wander_range, wander_range)
                y = self.position[1] + random.uniform(-wander_range, wander_range)
                self.target_position = (x, y)
            self.wandering = True
            self.wander_timer = random.uniform(5, 15)

        if self.wandering:
            self.move_to_target(dt)
            self.wander_timer -= dt

            if self.target_position and (distance(self.position, self.target_position) < TILE_SIZE or self.wander_timer <= 0):
                self.wandering = False
                self.wander_timer = random.uniform(2, 5)

    def move_to_target(self, dt):
        """Move toward target position"""
        if not self.target_position:
            return False

        direction_x = self.target_position[0] - self.position[0]
        direction_y = self.target_position[1] - self.position[1]
        
        dir_length = math.hypot(direction_x, direction_y)
        if dir_length == 0:
            return False

        direction_x /= dir_length
        direction_y /= dir_length
        
        speed = self.speed * dt
        move_x = direction_x * speed
        move_y = direction_y * speed
        new_pos = (self.position[0] + move_x, self.position[1] + move_y)

        if (self.terrain.is_water_at_position(new_pos) and 
            self.species != "crocodile" and 
            self.state != "seeking_water"):
            return False


        self.position = new_pos
        self.rect.center = self.position
        self.rotation = math.degrees(math.atan2(direction_y, direction_x))
        self.image = pygame.transform.rotate(self.base_image, -self.rotation + 90)

        return True

    def find_grass_locations(self):
        """Find suitable grass locations for food"""
        grass_locations = []
        
        search_radius = 20 * TILE_SIZE
        step = 5 * TILE_SIZE
        
        for x_offset in range(-int(search_radius), int(search_radius) + 1, int(step)):
            for y_offset in range(-int(search_radius), int(search_radius) + 1, int(step)):
                pos = (self.position[0] + x_offset, self.position[1] + y_offset)
                if self.terrain.get_terrain_at_position(pos) == "grass":
                    grass_locations.append(pos)
        
        return grass_locations
    
    def find_water_locations(self):
        """Find suitable water locations for drinking"""
        water_locations = []
        
        search_radius = 30 * TILE_SIZE
        step = 5 * TILE_SIZE
        
        for x_offset in range(-int(search_radius), int(search_radius) + 1, int(step)):
            for y_offset in range(-int(search_radius), int(search_radius) + 1, int(step)):
                pos = (self.position[0] + x_offset, self.position[1] + y_offset)
                if self.terrain.is_water_at_position(pos):
                    water_locations.append(pos)
        
        return water_locations


// File: building.py
import pygame
from constants import *

class Building(pygame.sprite.Sprite):
    def __init__(self, building_type, position, building_manager):
        super().__init__()
        
        config = building_manager.building_config[building_type]
        
        width = int(config['scale'][0] * TILE_SIZE)
        height = int(config['scale'][1] * TILE_SIZE)
        
        self.image = pygame.Surface((width, height), pygame.SRCALPHA)
        self.image.fill(config['color'])
        
        self.rect = self.image.get_rect()
        self.rect.center = position
        
        self.building_type = building_type
        self.position = position
        self.game_state = building_manager.game_state
        self.building_manager = building_manager
        self.terrain = building_manager.terrain
        
        self.health = 100
        self.last_maintenance = 0
        
        building_manager.buildings.append(self)
        
        cost = config['cost']
        building_manager.game_state.add_funds(-cost)
        building_manager.game_state.add_notification(f"Built {building_type} for ${cost}")
    
    def step(self, dt):
        """Update building state"""
        self.health -= 0.1 * dt
        
        if self.health < 30:
            if self.building_type == "feeding_station":
                self.health -= 0.2 * dt
        
        terrain_type = self.terrain.get_terrain_at_position(self.position)
        if terrain_type == "water":
            self.health -= 0.3 * dt
        
        self.health = max(0, self.health)
        
        if self.health < 30:
            config = self.building_manager.building_config[self.building_type]
            base_color = config['color']
            new_color = lerp_color(base_color, RED, 0.5)
            
            width, height = self.image.get_size()
            self.image = pygame.Surface((width, height), pygame.SRCALPHA)
            self.image.fill(new_color)
    
    def perform_maintenance(self):
        """Perform maintenance on the building"""
        damage = 100 - self.health
        cost = damage * 0.5
        
        if self.game_state.funds >= cost:
            self.game_state.add_funds(-cost)
            
            self.health = 100
            
            config = self.building_manager.building_config[self.building_type]
            
            width, height = self.image.get_size()
            self.image = pygame.Surface((width, height), pygame.SRCALPHA)
            self.image.fill(config['color'])
            
            self.game_state.add_notification(f"Repaired {self.building_type} for ${cost:.2f}")
            return True
        else:
            self.game_state.add_notification(f"Not enough funds to repair {self.building_type}")
            return False

// File: building_manager.py
import pygame
from building import Building

from constants import *
from utils import distance
from types import SimpleNamespace
class BuildingManager:
    def __init__(self, game_state, terrain):
        self.game_state = game_state
        self.terrain = terrain
        self.buildings = []
        self.buildings_group = pygame.sprite.Group()
        self.pending_building_type = None
        
        self.building_config = {
            "feeding_station": {
                "scale": (2, 2),
                "cost": 500,
                "maintenance_cost": 50,
                "color": ORANGE,
                "effectiveness": 1.0
            },
            "water_station": {
                "scale": (2, 2),
                "cost": 400,
                "maintenance_cost": 40,
                "color": BLUE,
                "effectiveness": 1.0
            },
            "path": {
                "scale": (1, 1),
                "cost": 100,
                "maintenance_cost": 10,
                "color": BROWN,
                "effectiveness": 1.0
            },
            "viewing_platform": {
                "scale": (3, 3),
                "cost": 700,
                "maintenance_cost": 50,
                "color": LIGHT_GRAY,
                "effectiveness": 1.0
            },
            "tree": {
                "scale": (1, 2),
                "cost": 50,
                "maintenance_cost": 5,
                "color": DARK_GRAY,
            },
            "bush": {
                "scale": (1, 0.5),
                "cost": 30,
                "maintenance_cost": 3,
                "color": GREEN,
            },
            "flower": {
                "scale": (0.5, 0.5),
                "cost": 20,
                "maintenance_cost": 2,
                "color": (128, 0, 255),
            },
            "pond": {
                "scale": (2, 2),
                "cost": 100,
                "maintenance_cost": 10,
                "color": LIGHT_BLUE,
            },
            "road": {
                "scale": (1, 1),
                "cost": 100,
                "maintenance_cost": 5,
                "color": BROWN,
            },
        }
    
    def place_building(self, building_type, world_pos):
        self.pending_building_type = building_type

        # check occupancy
        if self.is_position_occupied(world_pos):
            self.game_state.add_notification("Can't build there!")
            return False

        # pay cost
        cost = self.building_config[building_type]["cost"]
        self.game_state.add_funds(-cost)

        if building_type == "path":
            # convert terrain cell under mouse into a road tile
            gx, gy = self.terrain.world_to_grid(world_pos)
            self.terrain.terrain_grid[gy][gx]["type"] = "path"
            # redraw only that cell
            tx = gx * TILE_SIZE
            ty = gy * TILE_SIZE
            pygame.draw.rect(self.terrain.terrain_surface,
                            self.building_config["path"]["color"],
                            (tx, ty, TILE_SIZE, TILE_SIZE))
            self.buildings.append(SimpleNamespace(
                building_type="path",
                position=self.terrain.grid_to_world((gx,gy)),
                rect=pygame.Rect(tx, ty, TILE_SIZE, TILE_SIZE)
            ) )
            self.game_state.add_notification(f"Built road for ${cost}")
            return True

        # otherwise a “real” building
        b = Building(building_type, world_pos, self)
        self.buildings.append(b)
        self.game_state.add_notification(f"Built {building_type} for ${cost}")
        return True


    def snap_to_grid(self, position):
        grid_x, grid_y = self.world_to_grid(position)
        return self.grid_to_world((grid_x, grid_y))

    def is_position_occupied(self, world_pos):
            """
            True only if new building’s rect would *overlap* an existing one.
            Adjacent (=touching) is OK.
            """
            cfg = self.building_config.get(self.pending_building_type, {})
            w = int(cfg.get("scale",(1,1))[0] * TILE_SIZE)
            h = int(cfg.get("scale",(1,1))[1] * TILE_SIZE)
            new_rect = pygame.Rect(0,0,w,h)
            new_rect.center = world_pos

            for b in self.buildings:
                if new_rect.colliderect(b.rect):
                    return True
            return False
    
    def update(self, dt):
        """Update all non-road buildings each frame."""
        for b in list(self.buildings):
            # only real Building instances have step(); skip 'path' entries
            if getattr(b, "building_type", None) != "path":
                b.step(dt)
    
    def remove_building(self, building):
        """Remove a building from the game"""
        if building in self.buildings:
            self.buildings.remove(building)
            self.buildings_group.remove(building)
            self.game_state.add_notification(f"{building.building_type} has broken down completely")
    
    def render(self, screen, camera_offset):
        """Render all buildings with camera offset"""
        for building in self.buildings:
            if not hasattr(building, "image"):
                continue  # Skip rendering if no image (e.g., for paths)

            screen_pos = (building.position[0] - camera_offset[0], 
                        building.position[1] - camera_offset[1])
            
            if (screen_pos[0] < -100 or screen_pos[0] > SCREEN_WIDTH + 100 or
                screen_pos[1] < -100 or screen_pos[1] > SCREEN_HEIGHT + 100):
                continue
            
            rect = building.image.get_rect()
            rect.center = screen_pos
            
            screen.blit(building.image, rect)
    
    def get_monthly_maintenance_cost(self):
        """Calculate the total monthly maintenance cost for all buildings"""
        total_cost = 0
        for building in self.buildings:
            cost = self.building_config[building.building_type]["maintenance_cost"]
            health_factor = 1 + (1 - building.health / 100) 
            total_cost += cost * health_factor
        
        return total_cost
    
    def calculate_tourist_infrastructure_score(self):
        """Calculate a score for tourist infrastructure"""
        if not self.buildings:
            return 0

        path_count = len([b for b in self.buildings if getattr(b, "building_type", None) == "path"])
        platform_count = len([b for b in self.buildings if getattr(b, "building_type", None) == "viewing_platform"])

        base_score = min(80, path_count * 5 + platform_count * 15)

        # Only consider buildings with health (i.e., real Building instances)
        buildings_with_health = [b for b in self.buildings if hasattr(b, "health")]

        if not buildings_with_health:
            return base_score  # Avoid division by zero

        avg_health = sum(b.health for b in buildings_with_health) / len(buildings_with_health)
        health_factor = avg_health / 100

        return base_score * health_factor
    
    def save_buildings(self, filename="buildings.json"):
        """Save building data to a file"""
        building_data = []
        
        for building in self.buildings:
            data = {
                "building_type": building.building_type,
                "position": [building.position[0], building.position[1]],
                "health": building.health
            }
            building_data.append(data)
        
        with open(filename, 'w') as f:
            json.dump(building_data, f)
        
        return True
    
    def load_buildings(self, filename="buildings.json"):
        """Load building data from a file"""
        try:
            with open(filename, 'r') as f:
                building_data = json.load(f)
            
            for building in list(self.buildings):
                self.remove_building(building)
            
            for data in building_data:
                position = (data["position"][0], data["position"][1])
                building = Building(data["building_type"], position, self)
                building.health = data["health"]
                self.buildings_group.add(building)
            
            return True
        except Exception as e:
            print(f"Error loading buildings: {str(e)}")
            return False

// File: components.py
import pygame
import sys
import random
import math
import noise
import json
from datetime import datetime
from os import path
from constants import *

class Button:
    def __init__(self, x, y, width, height, text, color, hover_color, text_color=BLACK, font_size=20, action=None):
        self.rect = pygame.Rect(x, y, width, height)
        self.color = color
        self.hover_color = hover_color
        self.text = text
        self.text_color = text_color
        self.font = pygame.font.SysFont('Arial', font_size)
        self.action = action
        self.active = True
    
    def draw(self, screen):
        if not self.active:
            return
            
        mouse_pos = pygame.mouse.get_pos()
        
        if self.rect.collidepoint(mouse_pos):
            pygame.draw.rect(screen, self.hover_color, self.rect, border_radius=5)
        else:
            pygame.draw.rect(screen, self.color, self.rect, border_radius=5)
        
        pygame.draw.rect(screen, BLACK, self.rect, 2, border_radius=5)
        
        text_surface = self.font.render(self.text, True, self.text_color)
        text_rect = text_surface.get_rect(center=self.rect.center)
        screen.blit(text_surface, text_rect)
    
    def handle_event(self, event):
        if not self.active:
            return False
            
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            if self.rect.collidepoint(event.pos):
                if self.action:
                    self.action()
                return True
        return False
// File: economy_manager.py
import pygame
import random
from tourist import Tourist
from constants import *

class EconomyManager:
    def __init__(self, game_state, animal_manager, building_manager):
        self.game_state = game_state
        self.animals = animal_manager
        self.buildings = building_manager
        self.terrain = building_manager.terrain
        
        self.tourists = []
        self.tourists_group = pygame.sprite.Group()
        self.reviews = []
        self.avg_review_score = 3.0
        self.daily_income = 0
        self.monthly_expenses = 0
        
        self.day_timer = 0
        self.month_timer = 0
        
        self.base_tourist_rate = 5
        self.tourist_modifier = self.game_state.difficulty_settings["tourist_rate"]
        self.entrance_fee = 20
        
        self.vehicle_manager = None
    
    def update(self, dt):
        """Update economic systems"""
        self.day_timer += dt
        self.month_timer += dt
        
        if self.day_timer >= 120:
            self.day_timer = 0
            self.daily_update()
        
        if self.month_timer >= 120 * 30:
            self.month_timer = 0
            self.monthly_update()
        
        self.update_tourists(dt)
        
        self.spawn_tourists(dt)
    
    def daily_update(self):
        """Perform daily economic updates"""
        income = self.daily_income
        
        self.daily_income = 0
        
        self.game_state.add_notification(f"Daily revenue: ${income:.2f}")
    
    def monthly_update(self):
        """Perform monthly economic updates"""
        maintenance_cost = self.buildings.get_monthly_maintenance_cost()
        
        animal_food_cost = 0
        for animal in self.animals.animals:
            species_config = self.animals.species_config[animal.species]
            food_cost = species_config["food_consumption"] * 100
            animal_food_cost += food_cost
        
        staff_salary = 1000
        
        total_expenses = maintenance_cost + animal_food_cost + staff_salary
        
        self.game_state.add_funds(-total_expenses)
        
        self.monthly_expenses = 0
        
        self.game_state.add_notification(f"Monthly expenses: ${total_expenses:.2f}")
        self.game_state.add_notification(f"Current funds: ${self.game_state.funds:.2f}")
    
    def update_tourists(self, dt):
        """Update all tourists"""
        for tourist in list(self.tourists):
            if tourist.step(dt):
                pass
    
    def spawn_tourists(self, dt):
        """Spawn new tourists based on park reputation and time of day"""
        hour = (self.game_state.time_of_day) % 24
        
        if 8 <= hour <= 18:
            spawn_chance = 0.1 * dt
        else:
            spawn_chance = 0.01 * dt
        
        reputation_factor = (self.avg_review_score / 3)
        animal_appeal = self.animals.get_tourist_appeal() / 100
        infrastructure = self.buildings.calculate_tourist_infrastructure_score() / 100
        
        park_attractiveness = (reputation_factor * 0.3) + (animal_appeal * 0.5) + (infrastructure * 0.2)
        
        spawn_chance *= park_attractiveness * self.tourist_modifier
        
        max_tourists = 30
        current_tourists = len(self.tourists)
        if current_tourists >= max_tourists:
            return
        
        if random.random() < spawn_chance:
            terrain_size = self.terrain.size * TILE_SIZE
            entrance_x = terrain_size / 2 - 5 * TILE_SIZE
            entrance_y = 0
            entrance_pos = (entrance_x, entrance_y)
            
            tourist = Tourist(entrance_pos, self)
            self.tourists.append(tourist)
            self.tourists_group.add(tourist)
            
            self.game_state.add_funds(self.entrance_fee)
            self.daily_income += self.entrance_fee
    
    def add_review(self, score):
        """Add a review score (1-5) and update average"""
        self.reviews.append(score)
        
        if len(self.reviews) > 100:
            self.reviews.pop(0)
        
        self.avg_review_score = sum(self.reviews) / len(self.reviews) if self.reviews else 3.0
    
    def get_park_stats(self):
        """Get statistics about the park's performance"""
        return {
            "tourists": len(self.tourists),
            "review_score": self.avg_review_score,
            "animal_appeal": self.animals.get_tourist_appeal(),
            "infrastructure": self.buildings.calculate_tourist_infrastructure_score(),
            "daily_income": self.daily_income,
            "monthly_expenses": self.monthly_expenses
        }
        
    def render(self, screen, camera_offset):
        """Render all tourists with camera offset"""
        for tourist in self.tourists:
            screen_pos = (tourist.position[0] - camera_offset[0], 
                         tourist.position[1] - camera_offset[1])
            
            if (screen_pos[0] < -50 or screen_pos[0] > SCREEN_WIDTH + 50 or
                screen_pos[1] < -50 or screen_pos[1] > SCREEN_HEIGHT + 50):
                continue
            
            rect = tourist.image.get_rect()
            rect.center = screen_pos
            
            screen.blit(tourist.image, rect)
// File: constants.py
SCREEN_WIDTH = 1280
SCREEN_HEIGHT = 720
FPS = 60
TILE_SIZE = 32
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
DARK_GREEN = (0, 100, 0)
BLUE = (0, 0, 255)
LIGHT_BLUE = (0, 100, 255, 150)
YELLOW = (255, 255, 0)
GRAY = (128, 128, 128)
DARK_GRAY = (64, 64, 64)
LIGHT_GRAY = (192, 192, 192)
ORANGE = (255, 165, 0)
BROWN = (165, 42, 42)
PINK = (255, 105, 180)
OLIVE = (128, 128, 0)
LIGHT_RED = (255, 100, 100)
LIGHT_GREEN = (144, 238, 144)

STATE_MENU = 0
STATE_PLAYING = 1
STATE_PAUSED = 2
STATE_GAME_OVER = 3
STATE_WIN = 4
STATE_ANIMAL_OVERVIEW = 5
// File: game_state.py
import pygame
from datetime import datetime
from constants import *

class GameState:
    def __init__(self, difficulty="medium"):
        self.difficulty = difficulty
        self.day = 1
        self.time_of_day = 0
        self.game_speed = 0
        self.time_elapsed = 0
        
        self.load_difficulty_settings()
        
        self.animal_stats = {}
        self.ecosystem_balance = 100
        self.notifications = []
    
    def load_difficulty_settings(self):
        self.settings = {
            "easy": {
                "starting_funds": 10000,
                "animal_need_rate": 0.7,
                "tourist_rate": 1.3,
                "building_costs": 0.8,
                "win_profit_target": 20000
            },
            "medium": {
                "starting_funds": 7000,
                "animal_need_rate": 1.0,
                "tourist_rate": 1.0,
                "building_costs": 1.0,
                "win_profit_target": 25000
            },
            "hard": {
                "starting_funds": 5000,
                "animal_need_rate": 1.3,
                "tourist_rate": 0.7,
                "building_costs": 1.2,
                "win_profit_target": 30000
            }
        }
        
        self.difficulty_settings = self.settings[self.difficulty]
        self.funds = self.difficulty_settings["starting_funds"]
        self.profit_target = self.difficulty_settings["win_profit_target"]
    
    def update(self, dt):
        self.time_elapsed += dt
        self.time_of_day += dt * 0.2
        
        if self.time_of_day >= 24:
            self.time_of_day = 0
            self.day += 1
            self.add_notification(f"Day {self.day} has begun")
    
    def set_game_speed(self, speed):
        """Set game speed: 0=paused, 1=normal, 3=fast"""
        self.game_speed = speed if 0 <= speed <= 3 else 1
        speed_labels = {0: "Paused", 1: "Normal", 3: "Fast"}
        self.add_notification(f"Game speed: {speed_labels.get(speed, speed)}")
    
    def add_funds(self, amount):
        """Add or subtract funds"""
        self.funds += amount
        return self.funds
    
    def add_notification(self, message):
        """Add a notification to the queue"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.notifications.append({"time": timestamp, "message": message})
        
        if len(self.notifications) > 10:
            self.notifications.pop(0)
    
    def update_ecosystem_balance(self, animal_stats):
        """Update ecosystem balance based on animal health and population"""
        self.animal_stats = animal_stats
        
        if not animal_stats:
            self.ecosystem_balance = 0
            return
        
        total_health = 0
        species_count = 0
        
        for species, stats in animal_stats.items():
            if stats["population"] > 0:
                species_count += 1
                total_health += stats["avg_health"] * stats["population"]
        
        total_animals = sum(stats["population"] for stats in animal_stats.values())
        
        if total_animals > 0:
            avg_health = total_health / total_animals
            self.ecosystem_balance = min(100, (avg_health * 0.7) + (species_count / len(animal_stats) * 100 * 0.3))
        else:
            self.ecosystem_balance = 0
    
    def check_win_condition(self):
        """Check if the player has met the win conditions"""
        return self.funds >= self.profit_target and self.ecosystem_balance >= 75
    
    def check_lose_condition(self):
        """Check if the player has lost the game"""
        return self.funds < 0 or self.ecosystem_balance < 20
    
    def save_game(self, filename="savegame.json"):
        """Save current game state to a file"""
        save_data = {
            "difficulty": self.difficulty,
            "day": self.day,
            "time_of_day": self.time_of_day,
            "funds": self.funds,
            "ecosystem_balance": self.ecosystem_balance,
        }
        
        with open(filename, 'w') as f:
            json.dump(save_data, f)
        
        self.add_notification(f"Game saved to {filename}")
        return True
    
    def load_game(self, filename="savegame.json"):
        """Load game state from a file"""
        if not path.exists(filename):
            self.add_notification(f"Save file {filename} not found")
            return False
        
        try:
            with open(filename, 'r') as f:
                save_data = json.load(f)
            
            self.difficulty = save_data["difficulty"]
            self.day = save_data["day"]
            self.time_of_day = save_data["time_of_day"]
            self.funds = save_data["funds"]
            self.ecosystem_balance = save_data["ecosystem_balance"]
            
            self.load_difficulty_settings()
            
            self.add_notification(f"Game loaded from {filename}")
            return True
        except Exception as e:
            self.add_notification(f"Error loading game: {str(e)}")
            return False

// File: main_menu.py
import tkinter as tk
from settings_page import SafariSettingsApp
from new_game import NewAdventureWindow  # <- Import your class here
import pygame
import os

# Asset path
ASSET_DIR = "assets"

# Init mixer
pygame.mixer.init()

# Load sounds
bg_music = os.path.join(ASSET_DIR, "song.wav")
roar_sound = os.path.join(ASSET_DIR, "lion-roaring.mp3")

# Load and play background music
pygame.mixer.music.load(bg_music)
pygame.mixer.music.set_volume(0.5)  # Default volume
pygame.mixer.music.play(-1)

# Play roar sound once
roar = pygame.mixer.Sound(roar_sound)
roar.set_volume(0.5)
roar.play()

def open_settings():
    main_root.withdraw()
    settings_window = tk.Toplevel()
    SafariSettingsApp(settings_window, main_root, pygame.mixer.music, roar)

def open_new_game():
    main_root.withdraw()
    new_game_window = tk.Toplevel()
    NewAdventureWindow(new_game_window, main_root)
    new_game_window.protocol("WM_DELETE_WINDOW", lambda: (new_game_window.destroy(), main_root.deiconify()))

def exit_game():
    main_root.quit()

main_root = tk.Tk()
main_root.geometry("1024x600")
main_root.configure(bg="#88c999")

bg_image = tk.PhotoImage(file=os.path.join(ASSET_DIR, "main_menu_image.png"))  # Ensure PNG format
bg_label = tk.Label(main_root, image=bg_image)
bg_label.place(relwidth=1, relheight=1)

button_frame = tk.Frame(main_root, pady=20)
button_frame.place(relx=0.5, rely=0.7, anchor="center")

def make_button(text, cmd):
    return tk.Button(button_frame, text=text, width=18, height=2, font=("Helvetica", 10, "bold"),
                     bg="#c58b39", activebackground="#a4692f", command=cmd)

make_button("NEW GAME", open_new_game).grid(row=0, column=0, padx=10)
make_button("LOAD GAME", lambda: print("Load game")).grid(row=0, column=1, padx=10)
make_button("SETTINGS", open_settings).grid(row=0, column=2, padx=10)
make_button("EXIT", exit_game).grid(row=0, column=3, padx=10)

main_root.protocol("WM_DELETE_WINDOW", main_root.quit)
main_root.mainloop()
// File: main.py
import sys
import pygame
import random
import math
from datetime import datetime
import noise
import json
from os import path
from collections import defaultdict

from game_state import GameState
from terrain import TerrainGenerator
from building_manager import BuildingManager
from animal_manager import AnimalManager
from vehicle import VehicleManager
from economy_manager import EconomyManager
from ui import UIManager
from constants import *

UI_STATE_MAIN_MENU = "main_menu"
UI_STATE_SETTINGS = "settings"
UI_STATE_GAMEPLAY = "gameplay"

pygame.init()
ui_state = UI_STATE_MAIN_MENU
pygame.font.init()

def main(difficulty='medium'):
    """Main game function"""
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    pygame.display.set_caption("Safari Park - Pygame Edition")
    clock = pygame.time.Clock()

    game_state = GameState(difficulty)
    terrain    = TerrainGenerator(game_state)
    buildings  = BuildingManager(game_state, terrain)
    animals    = AnimalManager(game_state, terrain)
    economy    = EconomyManager(game_state, animals, buildings)
    vehicles   = VehicleManager(game_state, buildings, terrain, economy)
    ui         = UIManager(game_state, animals, buildings, economy)

    animals.set_building_manager(buildings)
    animals.update_animal_stats()
    economy.vehicle_manager = vehicles
    ui.create_menu_buttons()

    camera_offset = [0, 0]
    camera_speed  = 500

    running = True
    game_state.set_game_speed(1)

    while running:
        dt = clock.tick(FPS) / 1000.0
        mouse_pos = pygame.mouse.get_pos()
        keys      = pygame.key.get_pressed()

        if keys[pygame.K_w]:
            camera_offset[1] -= camera_speed * dt
        if keys[pygame.K_s]:
            camera_offset[1] += camera_speed * dt
        if keys[pygame.K_a]:
            camera_offset[0] -= camera_speed * dt
        if keys[pygame.K_d]:
            camera_offset[0] += camera_speed * dt

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_1:
                    game_state.set_game_speed(0)
                elif event.key == pygame.K_2:
                    game_state.set_game_speed(1)
                elif event.key == pygame.K_3:
                    game_state.set_game_speed(3)
                elif event.key == pygame.K_b:
                    ui.toggle_build_menu()
                elif event.key == pygame.K_TAB:
                    ui.toggle_animal_overview()
                elif event.key == pygame.K_f and ui.build_menu_active:
                    ui.select_building('feeding_station')
                elif event.key == pygame.K_w and ui.build_menu_active:
                    ui.select_building('water_station')
                elif event.key == pygame.K_p and ui.build_menu_active:
                    ui.select_building('path')
                elif event.key == pygame.K_v and ui.build_menu_active:
                    ui.select_building('viewing_platform')

            if ui.handle_event(event, camera_offset):
                continue

        if game_state.game_speed > 0:
            ts = game_state.game_speed
            animals.update(dt * ts)
            buildings.update(dt * ts)
            economy.update(dt * ts)
            vehicles.update(dt * ts)
            game_state.update(dt * ts)

        if game_state.check_win_condition():
            pygame.draw.rect(screen, (0,100,0,200),
                             (SCREEN_WIDTH//4, SCREEN_HEIGHT//4,
                              SCREEN_WIDTH//2, SCREEN_HEIGHT//2))
            win_text = ui.title_font.render("You Win!", True, WHITE)
            screen.blit(win_text,
                        (SCREEN_WIDTH//2 - win_text.get_width()//2,
                         SCREEN_HEIGHT//2 - win_text.get_height()//2))
            pygame.display.flip()
            pygame.time.wait(5000)
            running = False

        if game_state.check_lose_condition():
            pygame.draw.rect(screen, (100,0,0,200),
                             (SCREEN_WIDTH//4, SCREEN_HEIGHT//4,
                              SCREEN_WIDTH//2, SCREEN_HEIGHT//2))
            lose_text = ui.title_font.render("Game Over", True, WHITE)
            screen.blit(lose_text,
                        (SCREEN_WIDTH//2 - lose_text.get_width()//2,
                         SCREEN_HEIGHT//2 - lose_text.get_height()//2))
            pygame.display.flip()
            pygame.time.wait(5000)
            running = False

        screen.fill(BLACK)
        terrain.render(screen, camera_offset)
        buildings.render(screen, camera_offset)
        animals.render(screen, camera_offset)
        economy.render(screen, camera_offset)
        vehicles.render(screen, camera_offset)
        ui.draw(screen, camera_offset, mouse_pos)
        pygame.display.flip()

    pygame.quit()
    sys.exit()


if __name__ == '__main__':
    if len(sys.argv) > 1:
        difficulty = sys.argv[1].lower()
        if difficulty not in ['easy', 'medium', 'hard']:
            print("Invalid difficulty. Using 'medium' instead.")
            difficulty = 'medium'
    else:
        difficulty = 'medium'

    main(difficulty)

// File: new_game.py
import tkinter as tk
import subprocess
from tkinter import messagebox

class NewAdventureWindow:
    def __init__(self, root, main_menu_ref):
        self.root = root
        self.main_menu_ref = main_menu_ref
        self.root.title("New Adventure")
        self.root.geometry("600x400")
        self.root.configure(bg="#b2d8b2")
        self.placeholder = "Enter park name here"
        self.build_ui()

    def build_ui(self):
        container = tk.Frame(self.root, bg="#222222", bd=5, relief="ridge")
        container.place(relx=0.5, rely=0.5, anchor="center", width=400, height=250)

        tk.Label(container, text="NEW ADVENTURE", font=("Helvetica", 20, "bold"),
                 fg="yellow", bg="#222222").pack(pady=(10, 5))

        tk.Label(container, text="What is your safari park name?", font=("Helvetica", 13, "bold"),
                 fg="yellow", bg="#222222").pack()

        self.name_entry = tk.Entry(container, font=("Helvetica", 12), justify="center",
                                   bd=2, relief="solid", fg="gray", bg="white")
        self.name_entry.insert(0, self.placeholder)
        self.name_entry.bind("<FocusIn>", self.clear_placeholder)
        self.name_entry.pack(pady=10, ipadx=10, ipady=5)

        button_frame = tk.Frame(container, bg="#222222")
        button_frame.pack(pady=10)

        self.make_button(button_frame, "Back", self.on_back).grid(row=0, column=0, padx=10)
        self.make_button(button_frame, "Continue", self.on_continue).grid(row=0, column=1, padx=10)

    def make_button(self, parent, text, command):
        return tk.Button(parent, text=text, font=("Helvetica", 10, "bold"), width=10,
                         bg="#c58b39", fg="white", activebackground="#a4692f",
                         relief="raised", command=command)

    def clear_placeholder(self, event):
        if self.name_entry.get() == self.placeholder:
            self.name_entry.delete(0, tk.END)
            self.name_entry.config(fg="black")

    def on_back(self):
        self.root.destroy()
        self.main_menu_ref.deiconify()

    def on_continue(self):
        park_name = self.name_entry.get().strip()
        if not park_name or park_name == self.placeholder:
            messagebox.showwarning("Input Required", "Please enter a valid park name.")
            return
        self.root.destroy()
        subprocess.Popen(["python", "main.py"])


// File: settings_page.py
import tkinter as tk
from tkinter import ttk, messagebox

class SafariSettingsApp:
    def __init__(self, root, main_menu_ref, bg_music, roar):
        self.root = root
        self.main_menu_ref = main_menu_ref
        self.bg_music = bg_music
        self.roar = roar

        self.root.title("Safari Park Settings")
        self.root.geometry("600x500")
        self.root.configure(bg="#b2d8b2")
        self.build_ui()

    def build_ui(self):
        container = tk.Frame(self.root, bg="#333333", bd=3, relief="groove")
        container.place(relx=0.5, rely=0.5, anchor="center", width=500, height=400)

        tk.Label(container, text="Safari Settings", font=("Helvetica", 22, "bold"), fg="yellow", bg="#333333").pack(pady=15)

        self.music_slider = self.add_slider(container, "Music Volume")
        self.sfx_slider = self.add_slider(container, "SFX Volume")

        button_frame = tk.Frame(container, bg="#333333")
        button_frame.pack(pady=20)

        self.make_button(button_frame, "Apply Changes", self.apply_changes).grid(row=0, column=0, padx=5)
        self.make_button(button_frame, "Back", self.back).grid(row=0, column=1, padx=5)
        self.make_button(button_frame, "Exit Game", self.exit_game).grid(row=1, column=0, columnspan=2, pady=10)


    def add_slider(self, parent, label_text):
        frame = tk.Frame(parent, bg="#333333")
        frame.pack(pady=5)
        tk.Label(frame, text=label_text, font=("Helvetica", 11, "bold"), bg="#333333", fg="white").pack(anchor="w")
        slider = ttk.Scale(frame, from_=0, to=100, orient="horizontal", length=300)
        slider.set(50)
        slider.pack()
        return slider

    def make_button(self, parent, text, command):
        return tk.Button(parent, text=text, font=("Helvetica", 10, "bold"), width=14,
                         bg="#c58b39", fg="white", activebackground="#a4692f", command=command)

    def apply_changes(self):
        music_vol = self.music_slider.get() / 100.0
        sfx_vol = self.sfx_slider.get() / 100.0
        self.bg_music.set_volume(music_vol)
        self.roar.set_volume(sfx_vol)
        self.roar.play()  # play to test sfx
        messagebox.showinfo("Settings", f"Music: {int(music_vol*100)}%, SFX: {int(sfx_vol*100)}%")

    def back(self):
        self.root.destroy()
        self.main_menu_ref.deiconify()

    def exit_game(self):
        self.root.quit()

// File: terrain.py
import pygame
import random
import noise
from constants import *

class TerrainGenerator:
    def __init__(self, game_state, size=64):
        self.game_state = game_state
        self.size = size
        self.tile_size = TILE_SIZE
        self.water_threshold = 0.3
        self.grass_threshold = 0.7
        self.rocky_threshold = 0.9
        
        self.terrain_grid = self.generate_terrain_grid()
        
        self.terrain_surface = pygame.Surface((size * self.tile_size, size * self.tile_size), pygame.SRCALPHA)
        self.vegetation_surface = pygame.Surface((size * self.tile_size, size * self.tile_size), pygame.SRCALPHA)
        self.entrance_tile = (0, self.size // 2)
        self.exit_tile = (self.size - 1, self.size // 2)
        self.create_terrain_surfaces()
    
    def generate_terrain_grid(self):
        """Generate a 2D terrain grid using Perlin noise"""
        terrain_grid = []
        
        seed = random.randint(0, 1000)
        scale = 10.0
        octaves = 4
        persistence = 0.5
        lacunarity = 2.0
        
        for y in range(self.size):
            row = []
            for x in range(self.size):
                nx = x / self.size - 0.5
                ny = y / self.size - 0.5
                
                noise_value = noise.pnoise2(
                    nx * scale, 
                    ny * scale, 
                    octaves=octaves, 
                    persistence=persistence, 
                    lacunarity=lacunarity,
                    repeatx=1024,
                    repeaty=1024,
                    base=seed
                )
                
                noise_value = (noise_value + 1) / 2
                
                dist_from_center = ((x - self.size/2)**2 + (y - self.size/2)**2)**0.5
                center_factor = max(0, 1 - (dist_from_center / (self.size/3)))
                basin_effect = center_factor * 0.4
                noise_value = max(0, noise_value - basin_effect)
                
                if noise_value < self.water_threshold:
                    terrain_type = "water"
                elif noise_value < self.grass_threshold:
                    terrain_type = "grass"
                elif noise_value < self.rocky_threshold:
                    terrain_type = "rocky"
                else:
                    terrain_type = "mountain"
                
                row.append({
                    "type": terrain_type,
                    "value": noise_value
                })
            terrain_grid.append(row)
        
        return terrain_grid
    
    def create_terrain_surfaces(self):
        """Create pre-rendered surfaces for the terrain"""
        self.terrain_surface.fill((50, 150, 50))
        
        for y in range(self.size):
            for x in range(self.size):
                tile_data = self.terrain_grid[y][x]
                tile_x = x * self.tile_size
                tile_y = y * self.tile_size
                
                if tile_data["type"] == "water":
                    pygame.draw.rect(self.terrain_surface, LIGHT_BLUE, 
                                    (tile_x, tile_y, self.tile_size, self.tile_size))
                
                elif tile_data["type"] == "rocky":
                    pygame.draw.rect(self.terrain_surface, GRAY, 
                                    (tile_x, tile_y, self.tile_size, self.tile_size))
                
                elif tile_data["type"] == "mountain":
                    pygame.draw.rect(self.terrain_surface, DARK_GRAY, 
                                    (tile_x, tile_y, self.tile_size, self.tile_size))
        
        random.seed(42)
        
        num_trees = int(self.size * self.size * 0.01)
        num_bushes = int(self.size * self.size * 0.02)
        
        tree_color = DARK_GREEN
        bush_color = GREEN
        
        for _ in range(num_trees):
            x = random.randint(0, self.size - 1)
            y = random.randint(0, self.size - 1)
            
            if self.terrain_grid[y][x]["type"] == "grass":
                tree_x = x * self.tile_size + self.tile_size * 0.1
                tree_y = y * self.tile_size 
                tree_width = self.tile_size * 0.8
                tree_height = self.tile_size * 1.2
                
                pygame.draw.rect(self.vegetation_surface, BROWN, 
                                (tree_x + tree_width/3, tree_y + tree_height/2, tree_width/3, tree_height/2))
                pygame.draw.circle(self.vegetation_surface, tree_color, 
                                 (int(tree_x + tree_width/2), int(tree_y + tree_height/3)), 
                                 int(tree_width/2))
        
        for _ in range(num_bushes):
            x = random.randint(0, self.size - 1)
            y = random.randint(0, self.size - 1)
            
            if self.terrain_grid[y][x]["type"] == "grass":
                bush_x = x * self.tile_size + self.tile_size * 0.25
                bush_y = y * self.tile_size + self.tile_size * 0.25
                bush_size = self.tile_size * 0.5
                
                pygame.draw.circle(self.vegetation_surface, bush_color, 
                                 (int(bush_x + bush_size/2), int(bush_y + bush_size/2)), 
                                 int(bush_size/2))
    
    def world_to_grid(self, world_pos):
        """Convert world position to grid position"""
        grid_x = int((world_pos[0] + self.size * self.tile_size / 2) / self.tile_size)
        grid_y = int((world_pos[1] + self.size * self.tile_size / 2) / self.tile_size)
        
        grid_x = max(0, min(grid_x, self.size - 1))
        grid_y = max(0, min(grid_y, self.size - 1))
        
        return (grid_x, grid_y)
    
    def grid_to_world(self, grid_pos):
        """Convert grid position to world position"""
        world_x = grid_pos[0] * self.tile_size - self.size * self.tile_size / 2 + self.tile_size / 2
        world_y = grid_pos[1] * self.tile_size - self.size * self.tile_size / 2 + self.tile_size / 2
        
        return (world_x, world_y)
    
    def get_terrain_at_position(self, world_pos):
        """Get the terrain type at the given world position"""
        grid_x, grid_y = self.world_to_grid(world_pos)
        return self.terrain_grid[grid_y][grid_x]["type"]
    
    def is_water_at_position(self, world_pos):
        """Check if there is water at the given position"""
        return self.get_terrain_at_position(world_pos) == "water"
    
    def is_suitable_for_building(self, world_pos):
        """Check if the given position is suitable for building"""
        return self.get_terrain_at_position(world_pos) == "grass"
    
    def render(self, screen, camera_offset):
        """Render the terrain with camera offset"""
        viewport_rect = pygame.Rect(
            camera_offset[0], 
            camera_offset[1], 
            SCREEN_WIDTH, 
            SCREEN_HEIGHT
        )
        
        terrain_rect = pygame.Rect(
            viewport_rect.x + self.size * self.tile_size / 2,
            viewport_rect.y + self.size * self.tile_size / 2, 
            viewport_rect.width, 
            viewport_rect.height
        )
        
        screen.blit(self.terrain_surface, (-camera_offset[0] - self.size * self.tile_size / 2, 
                                          -camera_offset[1] - self.size * self.tile_size / 2))
        screen.blit(self.vegetation_surface, (-camera_offset[0] - self.size * self.tile_size / 2, 
                                            -camera_offset[1] - self.size * self.tile_size / 2))
    
    def save_terrain(self, filename="terrain.json"):
        """Save terrain data to a file"""
        serialized_grid = []
        for row in self.terrain_grid:
            serialized_row = []
            for tile in row:
                serialized_row.append({
                    "type": tile["type"],
                    "value": tile["value"]
                })
            serialized_grid.append(serialized_row)
            
        terrain_data = {
            "size": self.size,
            "terrain_grid": serialized_grid
        }
        
        with open(filename, 'w') as f:
            json.dump(terrain_data, f)
        
        return True
    
    def load_terrain(self, filename="terrain.json"):
        """Load terrain data from a file"""
        try:
            with open(filename, 'r') as f:
                terrain_data = json.load(f)
            
            self.size = terrain_data["size"]
            self.terrain_grid = terrain_data["terrain_grid"]
            
            self.terrain_surface = pygame.Surface((self.size * self.tile_size, self.size * self.tile_size), pygame.SRCALPHA)
            self.vegetation_surface = pygame.Surface((self.size * self.tile_size, self.size * self.tile_size), pygame.SRCALPHA)
            self.create_terrain_surfaces()
            
            return True
        except Exception as e:
            print(f"Error loading terrain: {str(e)}")
            return False

    def find_path(self, start, goal):
        from heapq import heappop, heappush

        def heuristic(a, b):
            return abs(a[0] - b[0]) + abs(a[1] - b[1])

        open_set = []
        heappush(open_set, (0, start))
        came_from = {}
        g_score = {start: 0}

        while open_set:
            _, current = heappop(open_set)
            if current == goal:
                path = []
                while current in came_from:
                    path.append(current)
                    current = came_from[current]
                return path[::-1]

            neighbors = [(current[0] + dx, current[1] + dy) 
                        for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]]

            for neighbor in neighbors:
                if not (0 <= neighbor[0] < self.size and 0 <= neighbor[1] < self.size):
                    continue
                if self.terrain_grid[neighbor[1]][neighbor[0]]["type"] != "path":
                    continue
                tentative_g = g_score[current] + 1
                if tentative_g < g_score.get(neighbor, float('inf')):
                    g_score[neighbor] = tentative_g
                    f_score = tentative_g + heuristic(neighbor, goal)
                    heappush(open_set, (f_score, neighbor))
                    came_from[neighbor] = current
        return []

// File: tourist.py
import pygame
import random
import math
from constants import *
from utils import distance

class Tourist(pygame.sprite.Sprite):
    def __init__(self, position, economy_manager):
        super().__init__()
        
        size = int(TILE_SIZE * 0.8)
        self.image = pygame.Surface((size, size), pygame.SRCALPHA)
        pygame.draw.circle(self.image, PINK, (size//2, size//2), size//2)
        
        self.rect = self.image.get_rect()
        self.rect.center = position
        
        self.position = position
        self.manager = economy_manager
        self.terrain = economy_manager.terrain
        self.game_state = economy_manager.game_state
        
        self.speed = random.uniform(2.0, 4.0) * (TILE_SIZE / 32)
        self.satisfaction = random.uniform(50, 70)
        self.spending_rate = random.uniform(5, 15)
        self.visit_duration = random.uniform(5, 15)
        self.time_spent = 0
        
        self.target_position = None
        self.path = []
        self.path_index = 0
        self.waiting_time = 0
    
    def step(self, dt):
        """Update tourist behavior"""
        self.time_spent += dt / 60
        
        self.update_satisfaction(dt)
        
        self.move(dt)
        
        if self.time_spent % 1.0 < dt / 60:
            self.spend_money()
        
        if self.time_spent >= self.visit_duration:
            self.leave()
            return True
        
        return False
    
    def update_satisfaction(self, dt):
        """Update satisfaction based on surroundings"""
        self.satisfaction -= 0.5 * dt / 60
        
        nearby_animals = [a for a in self.manager.animals.animals 
                          if distance(self.position, a.position) < TILE_SIZE * 10]
        
        if nearby_animals:
            species_seen = set(a.species for a in nearby_animals)
            self.satisfaction += len(species_seen) * 2 * dt / 60
            
            for animal in nearby_animals:
                if animal.species == "elephant" or animal.species == "lion":
                    self.satisfaction += 1 * dt / 60
        
        nearby_buildings = [b for b in self.manager.buildings.buildings 
                           if distance(self.position, b.position) < TILE_SIZE * 3]
        
        on_path = any(b.building_type == "path" for b in nearby_buildings)
        at_platform = any(b.building_type == "viewing_platform" for b in nearby_buildings)
        
        if on_path:
            self.satisfaction += 0.2 * dt / 60
        else:
            self.satisfaction -= 1.0 * dt / 60
        
        if at_platform:
            self.satisfaction += 2.0 * dt / 60
        
        self.satisfaction = max(0, min(100, self.satisfaction))
        
        if self.satisfaction > 80:
            color = GREEN
        elif self.satisfaction > 50:
            color = YELLOW
        elif self.satisfaction > 30:
            color = ORANGE
        else:
            color = RED
            
        size = int(TILE_SIZE * 0.8)
        self.image = pygame.Surface((size, size), pygame.SRCALPHA)
        pygame.draw.circle(self.image, color, (size//2, size//2), size//2)
    
    def move(self, dt):
        """Move around the park"""

        if self.waiting_time > 0:
            self.waiting_time -= dt
            return

        if self.path and self.path_index < len(self.path):
            self.target_position = self.path[self.path_index]
            if distance(self.position, self.target_position) < TILE_SIZE / 2:
                self.path_index += 1
                if self.path_index >= len(self.path):
                    self.path = []
                    self.target_position = None
                    self.waiting_time = random.uniform(5, 20)
                    return

        if not self.target_position or distance(self.position, self.target_position) < TILE_SIZE:
            self.choose_new_target()
            self.waiting_time = random.uniform(5, 20)
            return

        direction_x = self.target_position[0] - self.position[0]
        direction_y = self.target_position[1] - self.position[1]
        dir_length = math.sqrt(direction_x**2 + direction_y**2)
        if dir_length > 0:
            direction_x /= dir_length
            direction_y /= dir_length

        speed = self.speed * dt
        move_x = direction_x * speed
        move_y = direction_y * speed
        new_pos = (self.position[0] + move_x, self.position[1] + move_y)

        if not self.terrain.is_water_at_position(new_pos):
            self.position = new_pos
            self.rect.center = self.position

    
    def choose_new_target(self):
        """Choose a new target to move towards"""

        if not self.path:
            start_tile = self.terrain.world_to_grid(self.position)
            path = self.terrain.find_path(start_tile, self.terrain.exit_tile)
            if path:
                self.path = [self.terrain.grid_to_world(p) for p in path]
                self.path_index = 0
                self.target_position = self.path[self.path_index]
                return
            else:
                self.path = []

        paths = [b for b in self.manager.buildings.buildings 
                if b.building_type == "path"]
        platforms = [b for b in self.manager.buildings.buildings 
                    if b.building_type == "viewing_platform"]
        animals = self.manager.animals.animals

        if random.random() < 0.7 and paths:
            target = random.choice(paths)
            self.target_position = target.position
        elif random.random() < 0.8 and platforms:
            target = random.choice(platforms)
            self.target_position = target.position
        elif random.random() < 0.9 and animals:
            target = random.choice(animals)
            self.target_position = target.position
        else:
            terrain_size = self.terrain.size * TILE_SIZE
            x = random.uniform(-terrain_size / 2, terrain_size / 2)
            y = random.uniform(-terrain_size / 2, terrain_size / 2)
            while self.terrain.is_water_at_position((x, y)):
                x = random.uniform(-terrain_size / 2, terrain_size / 2)
                y = random.uniform(-terrain_size / 2, terrain_size / 2)
            self.target_position = (x, y)

    
    def spend_money(self):
        """Tourist spends money based on their satisfaction"""
        spending = self.spending_rate * (self.satisfaction / 50)
        
        self.manager.game_state.add_funds(spending)
    
    def leave(self):
        """Tourist leaves the park"""
        if self in self.manager.tourists:
            self.manager.tourists.remove(self)
            self.manager.tourists_group.remove(self)
        
        review_score = max(1, min(5, int(self.satisfaction / 20)))
        self.manager.add_review(review_score)

// File: ui.py
import pygame
from constants import *
from components import Button
from utils import distance

class UIManager:
    def __init__(self, game_state, animal_manager, building_manager, economy_manager):
        self.game_state = game_state
        self.animal_manager = animal_manager
        self.building_manager = building_manager
        self.economy_manager = economy_manager
        
        self.selected_building = None
        self.close_button = None
        self.build_menu_active = False
        self.animal_overview_active = False
        
        self.build_buttons = []
        self.time_buttons = []
        
        self.small_font = pygame.font.SysFont('Arial', 14)
        self.medium_font = pygame.font.SysFont('Arial', 18)
        self.large_font = pygame.font.SysFont('Arial', 24)
        self.title_font = pygame.font.SysFont('Arial', 32)
        
        self.notification_surface = pygame.Surface((int(SCREEN_WIDTH * 0.3), int(SCREEN_HEIGHT * 0.15)), pygame.SRCALPHA)
        
        self.create_menu_buttons()
    
    def create_menu_buttons(self):
        """Create the UI buttons"""
        button_y = SCREEN_HEIGHT - 40
        self.time_buttons = [
            Button(SCREEN_WIDTH//2 - 90, button_y, 60, 30, "Pause", GRAY, LIGHT_GRAY, 
                  action=lambda: self.game_state.set_game_speed(0)),
            Button(SCREEN_WIDTH//2 - 30, button_y, 60, 30, "Normal", GRAY, LIGHT_GRAY, 
                  action=lambda: self.game_state.set_game_speed(1)),
            Button(SCREEN_WIDTH//2 + 30, button_y, 60, 30, "Fast", GRAY, LIGHT_GRAY, 
                  action=lambda: self.game_state.set_game_speed(3))
        ]
        
        menu_x = 10
        menu_y = 60
        button_spacing = 40
        
        self.build_buttons = [
            Button(menu_x, menu_y, 30, 30, "F", ORANGE, LIGHT_RED, 
                  action=lambda: self.select_building("feeding_station")),
            Button(menu_x, menu_y + button_spacing, 30, 30, "W", BLUE, (100, 100, 255), 
                  action=lambda: self.select_building("water_station")),
            Button(menu_x, menu_y + button_spacing*2, 30, 30, "P", BROWN, (200, 150, 100), 
                  action=lambda: self.select_building("path")),
            Button(menu_x, menu_y + button_spacing*3, 30, 30, "V", LIGHT_GRAY, WHITE, 
                  action=lambda: self.select_building("viewing_platform")),
        ]
        
        if hasattr(self.economy_manager, 'vehicle_manager') and self.economy_manager.vehicle_manager:
            self.build_buttons.append(
                Button(menu_x, menu_y + button_spacing*4, 30, 30, "J", OLIVE, (200, 200, 100), 
                      action=lambda: self.economy_manager.vehicle_manager.purchase_jeep())
            )
        
        self.build_toggle_button = Button(menu_x, 10, 100, 30, "Build Menu", GREEN, LIGHT_GREEN, 
                                         action=self.toggle_build_menu)
        
        self.animal_overview_button = Button(menu_x + 110, 10, 140, 30, "Animal Overview", YELLOW, (255, 255, 150), 
                                          action=self.toggle_animal_overview)
    
    def toggle_build_menu(self):
        """Toggle the building menu"""
        self.build_menu_active = not self.build_menu_active
        
        for button in self.build_buttons:
            button.active = self.build_menu_active
    
    def toggle_animal_overview(self):
        """Toggle the animal overview panel"""
        self.animal_overview_active = not self.animal_overview_active
    
    def select_building(self, building_type):
        """Select a building type for placement"""
        self.selected_building = building_type
        self.game_state.add_notification(f"Selected {building_type} for placement. Click on the map to build.")
    
    def place_selected_building(self, position):
        """Place the selected building at the given position"""
        if self.selected_building:
            self.building_manager.place_building(self.selected_building, position)
    
    def draw_resource_display(self, screen):
        """Draw the resource display (money, etc.)"""
        pygame.draw.rect(screen, DARK_GRAY, (0, 0, SCREEN_WIDTH, 50))
        
        money_text = self.large_font.render(f"${self.game_state.funds:.2f}", True, GREEN)
        screen.blit(money_text, (SCREEN_WIDTH//2 - 150, 10))
        
        eco_text = self.large_font.render(f"Ecosystem: {self.game_state.ecosystem_balance:.1f}%", True, WHITE)
        screen.blit(eco_text, (SCREEN_WIDTH//2, 10))
        
        tourists = len(self.economy_manager.tourists)
        stars = "★" * int(self.economy_manager.avg_review_score) + "☆" * (5 - int(self.economy_manager.avg_review_score))
        tourist_text = self.large_font.render(f"Tourists: {tourists} ({stars})", True, YELLOW)
        screen.blit(tourist_text, (SCREEN_WIDTH//2 + 250, 10))
    
    def draw_time_display(self, screen):
        """Draw the time display"""
        day_text = f"Day {self.game_state.day}"
        hour = int(self.game_state.time_of_day)
        minute = int((self.game_state.time_of_day - hour) * 60)
        time_text = f"{hour:02d}:{minute:02d}"
        
        full_text = self.large_font.render(f"{day_text} - {time_text}", True, WHITE)
        screen.blit(full_text, (SCREEN_WIDTH//2 - 100, SCREEN_HEIGHT - 70))
        
        for button in self.time_buttons:
            button.draw(screen)
    
    def draw_notification_area(self, screen):
        """Draw the notification area"""
        self.notification_surface.fill((0, 0, 0, 150))
        
        if self.game_state.notifications:
            notifications = self.game_state.notifications[-3:]
            y_offset = 10
            
            title = self.medium_font.render("Notifications", True, WHITE)
            self.notification_surface.blit(title, (10, y_offset))
            y_offset += 25
            
            for notification in notifications:
                time_text = self.small_font.render(f"{notification['time']}: ", True, LIGHT_GRAY)
                msg_text = self.small_font.render(notification['message'], True, WHITE)
                
                self.notification_surface.blit(time_text, (10, y_offset))
                self.notification_surface.blit(msg_text, (70, y_offset))
                
                y_offset += 20
        
        screen.blit(self.notification_surface, (SCREEN_WIDTH - self.notification_surface.get_width() - 10, 
                                              SCREEN_HEIGHT - self.notification_surface.get_height() - 10))
    
    def draw_build_menu(self, screen):
        """Draw the build menu"""
        self.build_toggle_button.draw(screen)
        
        if self.build_menu_active:
            menu_width = 150
            menu_height = 250
            pygame.draw.rect(screen, (0, 0, 0, 180), (5, 55, menu_width, menu_height), border_radius=5)
            
            title = self.medium_font.render("Build Menu", True, WHITE)
            screen.blit(title, (50, 60))
            
            for button in self.build_buttons:
                button.draw(screen)
            
            mouse_pos = pygame.mouse.get_pos()
            for i, button in enumerate(self.build_buttons):
                if button.rect.collidepoint(mouse_pos) and button.active:
                    tooltip_text = ""
                    if i == 0:
                        tooltip_text = "Feeding Station - $500"
                    elif i == 1:
                        tooltip_text = "Water Station - $400"
                    elif i == 2:
                        tooltip_text = "Path - $100"
                    elif i == 3:
                        tooltip_text = "Viewing Platform - $700"
                    elif i == 4:
                        tooltip_text = "Jeep - $1000"
                    
                    if tooltip_text:
                        tooltip = self.small_font.render(tooltip_text, True, WHITE)
                        tooltip_bg = pygame.Rect(mouse_pos[0], mouse_pos[1] - 25, tooltip.get_width() + 10, 25)
                        pygame.draw.rect(screen, DARK_GRAY, tooltip_bg)
                        screen.blit(tooltip, (mouse_pos[0] + 5, mouse_pos[1] - 20))
    
    def draw_animal_overview(self, screen):
        """Draw the animal overview panel"""
        self.animal_overview_button.draw(screen)
        
        if self.animal_overview_active:
            panel_width = 400
            panel_height = 300
            panel_x = (SCREEN_WIDTH - panel_width) // 2
            panel_y = (SCREEN_HEIGHT - panel_height) // 2
            
            pygame.draw.rect(screen, (0, 0, 0, 200), (panel_x, panel_y, panel_width, panel_height), border_radius=10)
            pygame.draw.rect(screen, WHITE, (panel_x, panel_y, panel_width, panel_height), 2, border_radius=10)
            
            title = self.title_font.render("Animal Overview", True, WHITE)
            screen.blit(title, (panel_x + (panel_width - title.get_width()) // 2, panel_y + 10))
            
            self.close_button = Button(panel_x + panel_width - 30, panel_y + 10, 20, 20, "X", RED, LIGHT_RED, 
                                    action=self.toggle_animal_overview)
            self.close_button.draw(screen)

            species_stats = {}
            for species in self.animal_manager.species_config:
                group = [a for a in self.animal_manager.animals if a.species == species]
                pop = len(group)
                if pop:
                    avg_health = sum(a.health for a in group) / pop
                    avg_hunger = sum(a.hunger for a in group) / pop
                    avg_thirst = sum(a.thirst for a in group) / pop
                else:
                    avg_health = avg_hunger = avg_thirst = 0
                species_stats[species] = {
                    "population": pop,
                    "avg_health": avg_health,
                    "avg_hunger": avg_hunger,
                    "avg_thirst": avg_thirst
                }
            
            y_pos = panel_y + 50
            spacing = 30
            
            for species, stats in species_stats.items():
                species_text = self.medium_font.render(f"{species.capitalize()}: {stats['population']}", True, WHITE)
                screen.blit(species_text, (panel_x + 20, y_pos))
                
                bar_x = panel_x + 200
                bar_y = y_pos + 5
                bar_width = 150
                bar_height = 15
                
                pygame.draw.rect(screen, DARK_GRAY, (bar_x, bar_y, bar_width, bar_height))
                
                health_width = max(0, bar_width * stats['avg_health'] / 100)
                health_color = self.get_health_color(stats['avg_health'])
                pygame.draw.rect(screen, health_color, (bar_x, bar_y, health_width, bar_height))
                
                health_text = self.small_font.render(f"{stats['avg_health']:.1f}%", True, BLACK)
                screen.blit(health_text, (bar_x + bar_width // 2 - health_text.get_width() // 2, bar_y))
                
                y_pos += spacing
            
            eco_balance_text = self.medium_font.render(f"Ecosystem Balance: {self.game_state.ecosystem_balance:.1f}%", True, WHITE)
            screen.blit(eco_balance_text, (panel_x + 20, panel_y + panel_height - 40))
    
    def get_health_color(self, health):
        """Get a color based on health percentage"""
        if health > 80:
            return GREEN
        elif health > 50:
            return YELLOW
        elif health > 30:
            return ORANGE
        else:
            return RED
    
    def draw_building_preview(self, screen, camera_offset, mouse_pos):
        """Draw a preview of the building at mouse position"""
        if not self.selected_building:
            return
            
        world_x = mouse_pos[0] + camera_offset[0]
        world_y = mouse_pos[1] + camera_offset[1]
        world_pos = (world_x, world_y)
        
        config = self.building_manager.building_config[self.selected_building]
        
        width = int(config['scale'][0] * TILE_SIZE)
        height = int(config['scale'][1] * TILE_SIZE)
        
        preview = pygame.Surface((width, height), pygame.SRCALPHA)
        
        color_with_alpha = (*config['color'][:3], 150)
        preview.fill(color_with_alpha)
        
        screen_pos = (mouse_pos[0] - width // 2, mouse_pos[1] - height // 2)
        
        screen.blit(preview, screen_pos)
        
        valid_position = (self.building_manager.terrain.is_suitable_for_building(world_pos) and
                        not self.building_manager.is_position_occupied(world_pos))
        
        indicator_color = GREEN if valid_position else RED
        pygame.draw.rect(screen, indicator_color, (screen_pos[0], screen_pos[1], width, height), 2)
    
    def draw_cursor_info(self, screen, camera_offset, mouse_pos):
        """Draw information about what's under the cursor"""
        world_x = mouse_pos[0] + camera_offset[0]
        world_y = mouse_pos[1] + camera_offset[1]
        world_pos = (world_x, world_y)
        
        terrain_type = self.building_manager.terrain.get_terrain_at_position(world_pos)
        
        info_text = f"Terrain: {terrain_type.capitalize()}"
        
        for building in self.building_manager.buildings:
            if distance(building.position, world_pos) < TILE_SIZE:
                if hasattr(building, "health"):
                    info_text += f" | {building.building_type.capitalize()} (Health: {building.health:.0f}%)"
                else:
                    info_text += f" | {building.building_type.capitalize()}"
                break

        for animal in self.animal_manager.animals:
            if distance(animal.position, world_pos) < TILE_SIZE:
                info_text += f" | {animal.species.capitalize()} (H:{animal.health:.0f}% F:{animal.hunger:.0f}% W:{animal.thirst:.0f}%)"
                break
        
        info_surface = self.small_font.render(info_text, True, WHITE)
        screen.blit(info_surface, (10, SCREEN_HEIGHT - 20))
    
    def draw(self, screen, camera_offset, mouse_pos):
        """Draw all UI elements"""
        self.draw_resource_display(screen)
        self.draw_time_display(screen)
        self.draw_notification_area(screen)
        self.draw_build_menu(screen)
        
        if self.animal_overview_active:
            self.draw_animal_overview(screen)
        else:
            self.animal_overview_button.draw(screen)
        
        if self.selected_building:
            self.draw_building_preview(screen, camera_offset, mouse_pos)
        
        self.draw_cursor_info(screen, camera_offset, mouse_pos)
    
    def handle_event(self, event, camera_offset):
        """Handle UI events"""
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            self.build_toggle_button.handle_event(event)
            self.animal_overview_button.handle_event(event)
            
            for button in self.time_buttons:
                if button.handle_event(event):
                    return True

            if self.build_menu_active:
                for button in self.build_buttons:
                    if button.handle_event(event):
                        return True

            if self.animal_overview_active and self.close_button:
                if self.close_button.handle_event(event):
                    return True

            if self.selected_building and not self.animal_overview_active:
                mouse_pos = pygame.mouse.get_pos()
                world_x = mouse_pos[0] + camera_offset[0]
                world_y = mouse_pos[1] + camera_offset[1]
                world_pos = (world_x, world_y)

                self.place_selected_building(world_pos)
                return True

        return False

// File: vehicle.py
import pygame, math, random
from constants import *

class Jeep(pygame.sprite.Sprite):
    def __init__(self, terrain, economy_manager):
        super().__init__()
        self.terrain = terrain
        self.econ    = economy_manager

        size = (int(TILE_SIZE*1.5), TILE_SIZE)
        self.image = pygame.Surface(size, pygame.SRCALPHA)
        self.image.fill(OLIVE)
        self.rect  = self.image.get_rect()

        self.grid_path = []
        self.path_idx  = 0
        self.state     = "idle"
        self.capacity  = 4
        self.passengers = []

        ex, ey = terrain.grid_to_world(terrain.entrance_tile)
        self.position = (ex, ey)
        self.rect.center = self.position
        self.speed = 3.0 * (TILE_SIZE/32)

    def update(self, dt):
        if self.state == "idle":
            waiting = [t for t in self.econ.tourists 
                       if self.terrain.world_to_grid(t.position)==self.terrain.entrance_tile]
            if waiting:
                for t in waiting[:self.capacity]:
                    self.passengers.append(t)
                    self.econ.tourists.remove(t)
                    self.econ.tourists_group.remove(t)
                route = self.terrain.find_path(
                    self.terrain.entrance_tile,
                    self.terrain.exit_tile
                )
                self.grid_path = route
                self.path_idx = 0
                self.state = "to_exit"
        elif self.state in ("to_exit","to_entrance"):
            if self.path_idx < len(self.grid_path):
                target = self.terrain.grid_to_world(self.grid_path[self.path_idx])
                self._move_toward(target, dt)
                if math.hypot(self.position[0]-target[0], self.position[1]-target[1]) < 2:
                    self.path_idx += 1
            else:
                if self.state=="to_exit":
                    for _ in self.passengers: 
                        self.econ.daily_income += self.econ.entrance_fee
                        self.econ.game_state.add_funds(self.econ.entrance_fee)
                    self.passengers.clear()
                    route = self.terrain.find_path(
                        self.terrain.exit_tile,
                        self.terrain.entrance_tile
                    )
                    self.grid_path = route
                    self.path_idx = 0
                    self.state = "to_entrance"
                else:
                    self.state = "idle"

        self.rect.center = self.position

    def _move_toward(self, target, dt):
        dx = target[0]-self.position[0]
        dy = target[1]-self.position[1]
        dist = math.hypot(dx,dy)
        if dist>0:
            dx, dy = dx/dist, dy/dist
            self.position = (
                self.position[0] + dx*self.speed*dt,
                self.position[1] + dy*self.speed*dt
            )

class VehicleManager:
    def __init__(self, game_state, building_manager, terrain, economy_manager):
        self.game_state = game_state
        self.buildings = building_manager
        self.terrain   = terrain
        self.econ      = economy_manager

        self.vehicles = pygame.sprite.Group()

    def purchase_jeep(self):
        cost = 1000
        if self.game_state.funds < cost:
            self.game_state.add_notification("Not enough funds for jeep")
            return False

        self.game_state.add_funds(-cost)

        jeep = Jeep(self.terrain, self.econ)

        route = self.terrain.find_path(
            self.terrain.entrance_tile,
            self.terrain.exit_tile
        )
        if route:
            jeep.grid_path = route
            jeep.path_idx  = 0
            jeep.state     = "to_exit"

        self.vehicles.add(jeep)
        self.game_state.add_notification("Purchased a safari jeep!")
        return True

    def update(self, dt):
        for v in self.vehicles:
            v.update(dt)

    def render(self, screen, camera_offset):
        for v in self.vehicles:
            sx = v.position[0] - camera_offset[0]
            sy = v.position[1] - camera_offset[1]
            if -100 < sx < SCREEN_WIDTH+100 and -100 < sy < SCREEN_HEIGHT+100:
                rect = v.image.get_rect(center=(sx,sy))
                screen.blit(v.image, rect)

// File: utils.py
import math

def distance(pos1, pos2):
    return math.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)

def lerp_color(color1, color2, t):
    """Linear interpolation between two colors"""
    r = int(color1[0] + (color2[0] - color1[0]) * t)
    g = int(color1[1] + (color2[1] - color1[1]) * t)
    b = int(color1[2] + (color2[2] - color1[2]) * t)
    if len(color1) > 3 and len(color2) > 3:
        a = int(color1[3] + (color2[3] - color1[3]) * t)
        return (r, g, b, a)
    return (r, g, b)
